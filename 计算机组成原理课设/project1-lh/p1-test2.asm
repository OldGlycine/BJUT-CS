# 变量初始化工作
ori $16, $0, 1  	# 【$16 = 1】
ori $17, $0, 3		# 【$17 = 3】
ori $8, $0, 1		# 【$8 = 1】
ori $12, $0,0xabab	# 【$12 = abab】
lui $13, 10		# 【$13 = 10_0000】

# 函数start开始
start:addu $4, $0,$16	# 【$4 = (unsigned)$0 + $16】 
addu $5, $0,$8		# 【$5 = (unsigned)$0 + $8】  
jal newadd		# 【函数调用 $31 = 3020;jmp to 30c8】 
addu $16, $0, $2	# 【函数返回 (unsigned)$16 = $0 + $2】
subu $17,$17,$8		# 【(unsigned) $17 = $17 - $ 8】1
beq $16, $17, start	# 【beq $16 == $17 ? jmp to 3014 : jmp to 302c】
# 函数start结束
# 第一轮 : $4 = 1; $5 = 1; $0 = be01; $2 = 2; $16 = bddf + 2 = bde1; $17 = 2
# 结束

# 函数start2前准备工作
ori $8, $0,4		# 【$8 = bddf】
addiu $24,$0,0x7fffffff	# 【$24 = INTmax】
addiu $9,$24,3		# 【$9 = 1000_0002】
addiu $10,$24,5		# 【$10 = 1000_0004】
addu $0,$0,$0		# 【$0 *= 2】
addi $22,$24,6		# 【$22溢出,$30 = 1;$22 = 0】 ################
#ori $0, $0, 0

# 函数start2开始
start2:sw $9, 0($8)	# 【gpr[$8] = $9】以8号寄存器中的内容为基地址，加上偏移量0后的数据存储器地址的存储单元，存9号寄存器内容
lw $14, 0($8)		# 【$14 = gpr[$8]】以8号寄存器中的内容为基地址，加上偏移量0后 的数据存储器地址的存储单元的内容，存入14号寄存器
sw $10,4($8)		# 【gpr[$8 + 4] = $10】以8号寄存器的内容为基地址，加上偏移量4后的数据存储器地址的存储单元，存10号寄存器内容
lw $15,4($8)		# 【$15 = gpr[$8 + 4]】以8号寄存器的内容为基地址，加上偏移量4后的数据存储器地址的存储单元的内容，存入15号寄存器
sw $4, -4($8)		# 【gpr[$8 - 4] = $4】以8号寄存器的内容为基地址，加上偏移量-4后的数据存储器地址的存储单元，存4号寄存器内容
lw $18, -4($8)		# 【$18 = gpr[$8 - 4]】以8号寄存器的内容为基地址，加上偏移量-4后的数据存储器地址的存储单元的内容，存入18号寄存器
addu $4,$0,$8		# 【$4 = $0 + $8】8号寄存器内容 与 0号寄存器内容 进行无符号加法，结果存入4号寄存器
addu $5,$0,$9		# 【$5 = $0 + $9】9号寄存器内容 与 0号寄存器内容 进行无符号加法，结果存入5号寄存器
jal newadd		# 【函数调用】
slt $25,$10,$8		# 如果10号寄存器内容 小于 8号寄存器内容， 25号寄存器内容置1， 否则置0
beq $25, $0,end2	# 【程序终止判断】比较25号寄存器 与 0号寄存器内容（0）， 相等则跳转end2处，否则顺序执行
slt $20,$12,$4		# 如果12号寄存器内容 小于 4号寄存器内容， 20号寄存器内容置1， 否则置0
beq $20, $0, end1	# 【本函数结束判断】比较20号寄存器 与 0号寄存器内容（0）， 相等则跳转end1处，否则顺序执行
lui $12, 65535		# 将十进制65535(1_0000)加载到32位的高16位，低16位补0， 扩展结果存入12号寄存器(1000_000)
end1:ori $0, $0,1	# 0号寄存器内容 与 1 相或， 结果存0号寄存器
# 函数start2结束

# 函数start3前准备工作
lui $19, 0xefef		# 十六进制数efef加载至32位中的高16位，低位补0， 结果存入19号寄存器
addiu $3,$0,0xababcdcd	# 0号寄存器内容 无符号加立即数 ababcdcd（十六进制）， 结果存入3号寄存器中

# 函数start3开始
start3:addiu $4, $3, 2	# 3号寄存器内容 无符号加立即数2， 结果存入4号寄存器中
addi $23, $3, 5		# 3号寄存器内容 加 5， 有符号数的加法， 结果存23号寄存器。若结果溢出，30号寄存器存1，否则为0
jal newadd		# 将下一条指令地址存入31号寄存器， 跳转到newadd处
addu $8, $0, $2		# 0号寄存器内容 与 2号寄存器内容 进行无符号加法， 结果存8号寄存器
addu $4, $0, $8		# 0号寄存器内容 与 8号寄存器内容 进行无符号加法， 结果存4号寄存器
addu $5, $0, $9		# 0号寄存器内容 与 9号寄存器内容 进行无符号加法， 结果存5号寄存器
jal newadd		# 将下一条指令地址存入31号寄存器， 跳转到newadd处
addu $9, $0, $2		# 将2号寄存器内容与0号寄存器内容进行无符号加法，结果存入9号寄存器
addu $9, $8, $0		# 将0号寄存器内容与8号寄存器内容进行无符号加法，结果存入9号寄存器
lui $10, 0x69		# 将十六进制数69加载到32位数的高16位，低位补0，结果存入10号寄存器
beq $8, $9, start4	# 比较8号寄存器 和 9号寄存器的内容， 相等跳转start4处，否则顺序执行
beq $0, $0, start3	# 比较0号寄存器 和 0号寄存器的内容， 相等跳转start3处，否则顺序执行
start4:
j end		# 【程序结束】

# 【函数newadd】
newadd:addu $2, $4, $5	# 【函数进入 $2 = $4 + $5】4号寄存器内容 无符号加 5号寄存器内容， 结果存入2号寄存器中
addi $0,$12,0x1234	# 【重定义0  $0 = $12 + 1234】十六进制数1234 和12号寄存器的内容 有符号加法， 结果存0寄存器（0寄存器理论上无法被写入）
jr $31			# 【函数返回 jmp $31】跳转到 31号寄存器存储的内容 所指示的地址处
# 【函数末尾】

end2:addi $26,$0,0x5678	# 十六进制数5678 和 0号寄存器内容 有符号加法， 结果存26号寄存器
end:			# end标志处

